#include "Re.h"
using namespace std;

std::map<std::string, std::vector<std::string> > SpecialChar::SpecialCharMap;
bool SpecialChar::initialized = false;
char SpecialChar::Epsilon = '&';
int SpecialChar::CharType[128];
const char SpecialChar::OpAdd = '+';
const char SpecialChar::OpLeftBracket = '(';
const char SpecialChar::OpRightBracket = ')';
const char SpecialChar::OpOr = '|';
const char SpecialChar::OpStar = '*';
const char SpecialChar::OpTrans = '\\';
const char SpecialChar::OpNotGreedy = '?';

enumCharType SpecialChar::GetChaType(char cha)
{
    int chaIndex = (int)cha;
    if (chaIndex < 0)
    {
        Log::Instance()->logs("cant handle char < 0 || cha >= 128!   cha ->", cha);
        return enumCharType_Other;
    }

    return (enumCharType)CharType[chaIndex];
}

void SpecialChar::Initialize()
{
    if (!initialized)
    {
        //Do initialize here
        for (int i = 0; i <= 127; ++i)
        {
            if (SpecialChar::OpStar == i || SpecialChar::OpAdd == i || SpecialChar::OpLeftBracket == i || SpecialChar::OpRightBracket == i || SpecialChar::OpNotGreedy == i || SpecialChar::OpTrans == i || SpecialChar::OpOr == i)
            {
                CharType[i] = enumCharType_Op;
            }
            else
            {
                CharType[i] = enumCharType_Cha;
            }
        }

        initialized = true;
    }
}

bool SpecialChar::IsSpecialChar(std::string s)
{
    if (SpecialCharMap.find(s) != SpecialCharMap.end())
    {
        return true;
    }

    return false;
}

std::vector<std::string> SpecialChar::GetConvertedChars(std::string s)
{
    std::vector<std::string> emptyVec;
    std::map<std::string, std::vector<std::string> >::iterator itor = SpecialCharMap.find(s);
    if (itor != SpecialCharMap.end())
    {
        return itor->second;
    }

    return emptyVec;
}

ReItem::~ReItem()
{
    vector<int> emptyVec;
    m_VecStates.swap(emptyVec);
    m_SetStates.clear();

    for (auto itor = m_DicStateToFormerTransLine.begin(); itor != m_DicStateToFormerTransLine.end(); ++itor)
    {
        vector<TransLine* > vec = itor->second;
        if (vec.size() > 0)
        {
            for (int i = 0; i < vec.size(); ++i)
            {
                if (vec[i] != NULL)
                {
                    delete vec[i];
                    vec[i] = NULL;
                }
            }

            vector<TransLine* > emptyVec;
            vec.swap(emptyVec);
        }
    }

    m_DicStateToFormerTransLine.clear();
}

void ReItem::AddTrans(int from, int to, char c, char eplison)
{
    for (auto itor = m_DicStateToFormerTransLine.begin(); itor != m_DicStateToFormerTransLine.end(); ++itor)
    {
        vector<TransLine* > vecLines = itor->second;
        for (int i = 0; i < vecLines.size(); ++i)
        {
            if (vecLines[i]->iStartState == from && vecLines[i]->iEndState == to && vecLines[i]->cTransCha == c && vecLines[i]->epsilon == eplison)
            {
                Log::Instance()->logs("transition already exists!!!", from, " ===> ", to, " char:", c, " epsilon:", eplison);
                return;
            }
        }
    }

    if (iStartState > from)
    {
        iStartState = from;
    }
    if (iEndState < to)
    {
        iEndState = to;
    }

    TransLine* line = new TransLine;
    line->iStartState = from;
    line->iEndState = to;
    line->epsilon = eplison;
    line->cTransCha = c;
    if (m_SetStates.find(from) == m_SetStates.end())
    {
        m_SetStates.insert(from);
        m_VecStates.push_back(from);
    }
    if (m_SetStates.find(to) == m_SetStates.end())
    {
        m_SetStates.insert(to);
        m_VecStates.push_back(to);
    }
    
    if (m_DicStateToFormerTransLine.find(to) != m_DicStateToFormerTransLine.end())
    {
        m_DicStateToFormerTransLine[to].push_back(line);
    }
    else
    {
        vector<TransLine* > vec;
        vec.push_back(line);
        m_DicStateToFormerTransLine.insert(pair<int, vector<TransLine*> >(to, vec));
    }
}

void ReItem::AddTrans(TransLine* line)
{
    if (NULL == line)
    {
        return;
    }

    AddTrans(line->iStartState, line->iEndState, line->cTransCha, line->epsilon);
}

DFA::DFA(std::string s)
{
    SpecialChar::Initialize();
    m_reStr = s;
    BuildNFA();
    //BuildDFA();
}

DFA::~DFA()
{
    std::vector<int> emptyiVec;
    m_States.swap(emptyiVec);

    for (auto itor = this->m_DicStatesToNodes.begin(); itor != this->m_DicStatesToNodes.end(); ++itor)
    {
        if (itor->second != NULL)
        {
            delete itor->second;
            itor->second = NULL;
        }
    }

    std::vector<char> emprycVec;
    m_VecCha.swap(emprycVec);

    m_SetCha.clear();
}

bool DFA::Run(std::string reStr)
{
    if (m_reStr != reStr)
    {
        m_reStr = reStr;
        BuildDFA();
    }

    
    return false;
}

ReItem* DFA::BuildReItem(char cha)
{
    ReItem* item = new ReItem;
    item->AddTrans(0, 1, cha, -1);
    return item;
}

ReItem* DFA::BuildReItemWithStar(ReItem* node)
{
    if (NULL != node)
    {
        int endState = node->iEndState;
        int startState = node->iStartState;
        //epsilon trans
        node->AddTrans(endState, startState, SpecialChar::Epsilon, SpecialChar::Epsilon);
        node->AddTrans(endState, endState + 1, SpecialChar::Epsilon, SpecialChar::Epsilon);
        node->AddTrans(startState, endState + 1, SpecialChar::Epsilon, SpecialChar::Epsilon);
    }
    
    return node;
}

ReItem* DFA::BuildReItemWithAdd(ReItem* node)
{
    if (NULL != node)
    {
        int endState = node->iEndState;
        int startState = node->iStartState;
        //epsilon trans
        node->AddTrans(endState, startState, SpecialChar::Epsilon, SpecialChar::Epsilon);
    }

    return node;
}

ReItem* DFA::BuildReItemWithOr(ReItem* A, ReItem*& B)
{
    for (auto itor = A->m_DicStateToFormerTransLine.begin(); itor != A->m_DicStateToFormerTransLine.end(); ++itor)
    {
        for (int i = 0; i < itor->second.size(); ++i)
        {
            TransLine* line = itor->second[i];
            line->iStartState += 1;
            line->iEndState += 1;
        }
    }

    int endStateA = A->iEndState - A->iEndState;
    int endStateB = B->iEndState - B->iStartState;
    for (auto itor = B->m_DicStateToFormerTransLine.begin(); itor != B->m_DicStateToFormerTransLine.end(); ++itor)
    {
        for (int i = 0; i < itor->second.size(); ++i)
        {
            TransLine* line = itor->second[i];
            line->iStartState += endStateA + 2;
            line->iEndState += endStateA + 2;
            A->AddTrans(line);
        }
    }

    B->iStartState += endStateA + 2;
    B->iEndState += endStateA + 2;

    A->AddTrans(0, A->iStartState, SpecialChar::Epsilon, SpecialChar::Epsilon);
    A->AddTrans(0, B->iStartState, SpecialChar::Epsilon, SpecialChar::Epsilon);
    A->AddTrans(A->iEndState, B->iEndState + 1, SpecialChar::Epsilon, SpecialChar::Epsilon);
    A->AddTrans(B->iEndState, B->iEndState + 1, SpecialChar::Epsilon, SpecialChar::Epsilon);
    delete B;
    B = NULL;

    return A;
}

ReItem* DFA::BuildReItemWithNotGreedy(ReItem* node)
{
    return node;
}

ReItem* DFA::BuildReItemWithBracket(ReItem* node)
{
    return node;
}

ReItem* DFA::BuildReItemWithLink(ReItem* A, ReItem*& B)
{
    int endStateA = A->iEndState - A->iStartState;
    int endStateB = B->iEndState - B->iStartState;
    A->iEndState += endStateB;
    for (auto itor = B->m_DicStateToFormerTransLine.begin(); itor != B->m_DicStateToFormerTransLine.end(); ++itor)
    {
        for (int i = 0; i < itor->second.size(); ++i)
        {
            TransLine* line = itor->second[i];
            line->iStartState += endStateA;
            line->iEndState += endStateA;
            A->AddTrans(line);
        }
    }

    delete B;
    B = NULL;

    return A;
}

bool DFA::CheckReSyntax(std::string str) const
{
    stack<char> tmpStack;
    for (unsigned int i = 0; i < str.length(); ++i)
    {
        bool matched = true;
        char cha = str[i];
        switch (cha)
        {
        case '(':
            tmpStack.push(cha);
            break;
        case '|':
            tmpStack.push(cha);
            break;
        case ')':
            matched = false;
            while (!tmpStack.empty())
            {
                if (tmpStack.top() == '|')
                {
                    tmpStack.pop();
                }
                else if (tmpStack.top() == '(')
                {
                    matched = true;
                    tmpStack.pop();
                    break;
                }
            }
            break;
        default:
            break;
        }

        if (matched == false)
        {
            Log::Instance()->logs("\n\n");
            Log::Instance()->logs(str, " <== Re Syntax Error");
            char* s = new char[str.length() + 2];
            for (unsigned int j = 0; j < str.length(); ++j)
            {
                s[j] = ' ';
            }

            s[i + 1] = '^';
            s[str.length()] = '\0';
            s[str.length() + 1] = '\0';
            Log::Instance()->logs(s);

            return false;
        }
    }

    while (!tmpStack.empty())
    {
        if (tmpStack.top() == '(' || tmpStack.top() == ')')
        {
            Log::Instance()->logs(">>ChechReSyntax: ", str, false);
            return false;
        }

        tmpStack.pop();
    }

    Log::Instance()->logs(">>ChechReSyntax: ", str, true);
    return true;
}

std::string DFA::Strip(std::string str, char firstCha, char lastChar)
{
    string retStr = str;
    string tmpStr = str;
    for (unsigned int i = 0; i < str.length() / 2; ++i)
    {
        int len = retStr.length();
        if (len > 2 && retStr[0] == '(' && retStr[len - 1] == ')')
        {
            tmpStr = retStr.substr(1, len - 2);
            if (CheckReSyntax(tmpStr))
            {
                retStr = tmpStr;
            }
            else
            {
                return retStr;
            }
        }
        else if (len == 2 && retStr[0] == '(' && retStr[len - 1] == ')')
        {
            return "";
        }
        else
        {
            break;
        }
    }

    return retStr;
}

void DFA::BuildNFA()
{
    std::stack<ReItem*> nodeStack;
    std::stack<ReOp> operatorStack;
    char lastCha = -1;
    for (unsigned int i = 0; i < m_reStr.length(); ++i)
    {
        enumCharType lastCharType = SpecialChar::GetChaType(lastCha);
        char cha = m_reStr.at(i);

        char nextCha = -1; 
        if(i + 1 < m_reStr.length())
            nextCha = m_reStr.at(i + 1);

        if (cha < 0)
        {
            Log::Instance()->logs("Cant handle cha < 0: ", cha, "  m_reStr:", m_reStr);
            return;
        }

        switch (SpecialChar::GetChaType(cha))
        {
        case enumCharType_Cha:
        {
            if (operatorStack.size() > 0 && operatorStack.top().op == SpecialChar::OpLeftBracket)
            {
                ReOp op = operatorStack.top();
                operatorStack.pop();
                ++op.popNum;
                operatorStack.push(op);
            }

            if (m_SetCha.find(cha) == m_SetCha.end())
            {
                m_SetCha.insert(cha);
                m_VecCha.push_back(cha);
            }

            //is the first character
            if (lastCha == -1 && i == 0)
            {
                nodeStack.push(BuildReItem(cha));
            }
            //the former character is letter or )
            else if (lastCharType == enumCharType_Cha || (lastCharType == enumCharType_Op && lastCha == ')'))
            {
                if (nodeStack.size() == 1 && operatorStack.size() == 0 && (nextCha != -1 && SpecialChar::GetChaType(nextCha) != enumCharType_Op) )
                {
                    ReItem* A = nodeStack.top();
                    nodeStack.pop();
                    ReItem* B = BuildReItem(cha);
                    A = BuildReItemWithLink(A, B);
                    nodeStack.push(A);
                }
                else if(nextCha != -1 && SpecialChar::GetChaType(nextCha) == enumCharType_Op)
                {
                    ReItem* B = BuildReItem(cha);
                    nodeStack.push(B);
                }
                else
                {
                    Log::Instance()->logs("Syntax error at index ", i, " m_reStr:", m_reStr);
                    return;
                }
            }
            else if(lastCharType == enumCharType_Op)
            {
                ReItem* B = BuildReItem(cha);
                nodeStack.push(B);
            }
            else if(lastCharType == enumCharType_Other)
            {
                Log::Instance()->logs("Syntax error at index ", i, " m_reStr:", m_reStr);
                return;
            }

            break;
        }
        case enumCharType_Op:
        {
            switch (cha)
            {
                case SpecialChar::OpAdd:
                {
                    ReItem* B = nodeStack.top();
                    nodeStack.pop();
                    B = BuildReItemWithAdd(B);
                    nodeStack.push(B);
                    break;
                }
                case SpecialChar::OpStar:
                {
                    ReItem* B = nodeStack.top();
                    nodeStack.pop();
                    B = BuildReItemWithStar(B);
                    nodeStack.push(B);
                    break;
                }
                case SpecialChar::OpLeftBracket:
                {
                    ReOp op;
                    op.op = SpecialChar::OpLeftBracket;
                    op.popNum = 0;
                    operatorStack.push(op);
                    break;
                }
                case SpecialChar::OpRightBracket:
                {
                    if (operatorStack.size() > 0 && operatorStack.top().op == SpecialChar::OpLeftBracket)
                    {
                        int popNum = operatorStack.top().popNum;
                        operatorStack.pop();
                        if (operatorStack.size() > 0 && operatorStack.top().op == SpecialChar::OpLeftBracket)
                        {
                            ReOp op = operatorStack.top();
                            operatorStack.pop();
                            ++op.popNum;
                            operatorStack.push(op);
                        }

                        while (popNum >= 2)
                        {
                            ReItem* B = nodeStack.top();
                            nodeStack.pop();
                            ReItem* A = nodeStack.top();
                            nodeStack.pop();
                            A = BuildReItemWithLink(A, B);
                            nodeStack.push(A);
                            --popNum;
                        }
                    }
                    else
                    {
                        Log::Instance()->logs("Syntax error at index ", i, " m_reStr:", m_reStr);
                        return;
                    }

                    break;
                }
                case SpecialChar::OpOr:
                {
                    ReOp op;
                    op.op = cha;
                    op.popNum = 0;
                    operatorStack.push(op);
                    break;
                }
                default:
                {
                    ReOp op;
                    op.op = cha;
                    op.popNum = 0;
                    operatorStack.push(op);
                    break;
                }
            }
            break;
        }
        case enumCharType_Other:
        {
            Log::Instance()->logs("Syntax error at index ", i, " m_reStr:", m_reStr);
            return;
            break;
        }
        }

        lastCha = cha;
        //handle operator or |
        if (cha != SpecialChar::OpOr && (nextCha == -1 || nextCha == SpecialChar::OpRightBracket))
        {
            while (operatorStack.size() > 0 && operatorStack.top().op == SpecialChar::OpOr)
            {
//                 if (nextCha != -1
//                     && (nextCha == SpecialChar::OpAdd || nextCha == SpecialChar::OpStar || nextCha == SpecialChar::OpRightBracket)
//                     )
//                 {
//                     Log::Instance()->logs("Syntax error at index ", i, " m_reStr:", m_reStr);
//                     return;
//                 }
//                 else if (nextCha != -1
//                     && (nextCha == SpecialChar::OpLeftBracket)
//                     )
//                 {
//                     break;
//                 }

                if (nodeStack.size() >= 2)
                {
                    ReItem* B = nodeStack.top();
                    nodeStack.pop();
                    ReItem* A = nodeStack.top();
                    nodeStack.pop();
                    A = BuildReItemWithOr(A, B);
                    nodeStack.push(A);
                    operatorStack.pop();
                }
                else
                {
                    Log::Instance()->logs("Syntax error at index ", i, " m_reStr:", m_reStr);
                    return;
                }
            }
        }
    }

    while (nodeStack.size() >= 2)
    {
        ReItem* b = nodeStack.top();
        nodeStack.pop();
        ReItem* a = nodeStack.top();
        nodeStack.pop();
        a = BuildReItemWithLink(a, b);
        nodeStack.push(a);
    }

    ReItem* nfa = NULL;
    if(nodeStack.size() > 0)
        nfa = nodeStack.top();
    DFA::Print(nfa);
}

void DFA::BuildDFA()
{
    if (!CheckReSyntax(m_reStr))
    {
        return;
    }

    Log::Instance()->logs("BuildDFA end", m_reStr);
}

void DFA::Print(ReItem* item)
{
    if (NULL == item)
    {
        return;
    }

    stringstream s;
    s << "\nAllStates: \n";
    for (auto itor = item->m_VecStates.begin(); itor != item->m_VecStates.end(); ++itor)
    {
        s << *itor << " , ";
    }

    s << "\n\n";
    s << "Transitions: \n";
    for (auto itor = item->m_DicStateToFormerTransLine.begin(); itor != item->m_DicStateToFormerTransLine.end(); ++itor)
    {
        for (int i = 0; i < itor->second.size(); ++i)
        {
            TransLine* line = itor->second.at(i);
            if (line != NULL)
            {
                s << line->iStartState << " ==== " << line->cTransCha << "," << line->epsilon << "\t====> " << line->iEndState << " \n";
            }
        }
    }
    Log::Instance()->logs(s.str());
    s.clear();
}

bool Re::Match(std::string reStr)
{

    return false;
}

DFA Re::Compile(std::string reStr)
{
    m_reStr = reStr;

    return DFA(reStr);
}


